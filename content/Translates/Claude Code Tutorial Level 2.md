---
description: 这是官方 Claude Code 教程的第二部分，我将在这里讲解更多进阶概念，帮助你更好地利用 Claude Code。如果你还没有阅读第一部分，强烈建议你先看那篇文章。本篇内容是在第一部分基础上进一步拓展的。
source: https://x.com/eyad_khrais/article/2010810802023141688
author:
  - "[[Eyad@eyad_khrais·1月13日·]]"
created: 2026-01-14
tags:
  - clippings
---
这是官方 Claude Code 教程的第二部分，我将在这里讲解更多进阶概念，帮助你更好地利用 Claude Code。如果你还没有阅读第一部分，强烈建议你先看那篇文章。

本篇内容是在第一部分基础上进一步拓展的。

第一部分已经超级火了，但如果你错过了，先在这里阅读：  
https://x.com/eyad_khrais/status/2010076957938188661?s=20

我做了 7 年软件工程师，曾在 Amazon、Disney 和 Capital One 工作过。我写的代码影响了数百万用户。第一部分讲了大多数人容易出错的基础知识，但这篇文章会更深入地探讨 Claude Code 背后的系统，帮助大家从合格使用者进阶到卓越使用者。

大多数人仍然不知道如何有效使用的三个主要功能是：技能、子代理和 MCP 连接器。这些功能都在文档里，唯一的问题是文档没有告诉你这些部分在实际操作中如何组合，也没有说明哪些配置对真正的工作才重要。

以下是我每天用这些系统构建生产级软件后学到的所有经验。有些内容我花了几周才弄明白，有些则是通过反复试错得出的。希望能帮你节省一些时间。

## 上下文窗口问题

在我们深入高级功能之前，有一件基础的事情会影响到其他所有内容。

如果你正在使用多个 AI 编程工具，你可能以为它们处理上下文的方式都是一样的（其实不是）。根据 Qodo 工程团队的详细对比，Claude Code 提供了“更可靠且明确的 20 万 token 上下文窗口”，而 Cursor 由于“内部为性能或成本管理进行截断”，其“实际使用往往达不到理论上的 20 万 token 限制”。系统会自动应用内部保护措施，悄悄减少你的有效上下文。我在第一部分已经讲过为什么上下文如此重要。

虽然你可能会因为 Cursor 有这些限制而感到不满，但你得明白，不同的工具是为不同的工作流程优化的。如果你在处理大型、相互关联的代码库，需要模型理解你的认证系统如何连接到 API 路由，以及这些又如何连接到数据库结构，这些上下文就很重要。所以对于更大的项目，我建议直接使用 Claude Code。Claude Code 能始终如一地提供完整的 200K。

这也是为什么我接下来要介绍的这些功能在 Claude Code 中表现得特别好。技能、子代理和 MCP 连接都能从可预测的上下文中受益。

## Skills：教 Claude 你的特定工作流程

技能是一个 Markdown 文件，用来教 Claude 如何完成与你工作相关的特定任务。当你向 Claude 提问内容与某个技能的用途匹配时，它会自动应用该技能。结构非常简单。

- 创建一个包含 `SKILL.md` 文件的文件夹：  
  `~/.claude/skills/your-skill-name/SKILL.md`
- 每个 `SKILL.md` 都以 YAML 前置内容开始：

```yaml
name: code-review-standards
description: 在审核 PR 或提出改进建议时，请遵循我们团队的代码审查标准。适用于代码评审、讨论最佳实践或用户请求对实现方案进行反馈时。
```

描述非常关键。Claude 会根据描述来决定何时应用该技能。请具体说明触发条件。你也可以直接告诉 Claude “使用 x 技能”，它也会执行。但我们的目标是让 Claude 能够自主识别何时需要使用该技能。

在前置内容下面，用 Markdown 写出实际的指令。以下是一个最简示例：

```markdown
---
name: commit-messages
description: 按照我们团队的规范生成提交信息。用于创建提交或当用户请求提交信息帮助时使用。
---

# 提交信息格式

所有提交都遵循规范化提交格式：
- 新增：新功能
- 修复：漏洞修复
- 重构：代码更改，既不修复也不新增
- docs：仅文档
- 测试：添加或更新测试

格式：`type(scope): description`

示例：`feat(auth): 添加密码重置流程`
```

描述保持在 50 字以内。如需更多上下文，先空一行再写正文。刚开始用这种格式会有点别扭（毕竟平时习惯写正常的英文句子），但这样质量会明显提升。

关键的架构原则是渐进式披露。Claude 在启动时只预加载每个已安装技能的名称和描述（每项大约 100 个 token）。只有当 Claude 判断某个技能相关时，才会加载完整的指令，这意味着你可以拥有几十个技能而不会让上下文变得臃肿。

你可以将辅助文件添加到你的技能文件夹中。如果你有大量参考资料，请将其放在单独的文件里，并在 `SKILL.md` 中引用。Claude 只会在需要时读取这些内容。

同样重要的是要注意，技能不仅仅局限于代码。我见过工程师们为以下方面构建技能：

- 特定于其模式的数据库查询模式
- 他们公司使用的 API 文档格式
- 会议记录模板
- 甚至像餐饮计划或旅行预订这样的个人工作流程

这种模式适用于任何你需要反复向 Claude 解释相同背景或偏好的情况。

要查看当前加载了哪些技能，可以直接问 Claude：“你有哪些可用的技能？”它会列出来（或者进入设置 → 功能 → 向下滚动，你就能看到技能）。

## Subagents：使用隔离上下文进行并行处理

子代理是一个独立的 Claude 实例，拥有自己的上下文窗口、系统提示和工具权限。这正是 Claude Code 架构真正与众不同的地方。当 Claude 委派任务给子代理时，该子代理会独立运行，并向主对话返回摘要。

重要的是要记住，大约在你上下文窗口的 45% 时会发生上下文退化。子代理允许你将复杂的研究或实现任务转移到一个全新的上下文中，然后只带回相关的结果，这样你的主对话就能保持简洁。

Claude Code 包含三个内置子代理：

- Explore：用于搜索和分析代码库的快速只读代理。当 Claude 需要理解你的代码但不做修改时，会委托给这里。正确使用时，Claude 会指定细致程度：快速、中等或非常细致。
- Plan：在计划模式下使用的研究代理，用于在提出计划前收集上下文。它会调查你的代码库并返回发现结果，以便 Claude 能够做出明智的架构决策。
- 通用型：适用于需要探索和执行的复杂多步骤任务的强大代理。当任务需要多个相互依赖的步骤或复杂推理时，Claude 会在这里进行委派。

### 创建自定义子代理

就像你需要自定义技能一样，我强烈建议你创建自己的自定义子代理。在 Claude Code 中运行 `/agents`，可以查看所有可用的子代理并创建新的子代理。

一个典范结构（示例）：

```yaml
name: security-reviewer
description: 审查代码中的安全漏洞。在检查认证问题、注入风险或数据泄露时调用。
tools: Read, Grep, Glob
```

（系统提示示例要点）
- 你是一个关注安全的代码审查员。分析代码时：
- 检查身份验证与授权缺口
- 查找注入漏洞（SQL、命令注入、XSS）
- 识别敏感数据暴露风险
- 标记不安全依赖

请为每项发现提供具体的文件和行号引用。按严重程度分类：严重、较高、中等、较低。

`tools` 字段控制子代理可以做什么。对于只读审查员，只允许使用 `read`、`grep` 和 `glob` 命令。对于实现代理，则包括 `write`、`edit` 和 `bash` 命令。

### 子代理如何沟通

- 主代理识别出适合委托的任务
- 主代理通过特定提示调用子代理来描述任务
- 子代理在其自己的上下文窗口中执行
- 子代理向主代理返回发现/行动的摘要
- 主代理整合摘要并继续

总结是关键。一个设计良好的子代理不会把全部上下文都返回。这就是为什么子代理描述和系统提示需要明确输出格式。

### 串联子代理（示例）

主代理负责协调：

- 将研究委托给 Explore 子代理  
  - 返回：“找到 3 个相关文件：auth.py、middleware.py、routes.py”
- 将实现委托给自定义实现者子代理  
  - 返回：“已添加密码重置端点，更新了 2 个文件”
- 将测试委托给自定义测试运行子代理  
  - 返回：“全部 12 项测试通过，覆盖率达 94%”

每个子代理都会为其特定任务获取全新的上下文。主代理只保留摘要，而不是完整的探索历史。这样可以防止上下文污染，避免长时间编程时出现问题。

一个重要的限制：子代理不能生成其他子代理。这样可以防止无限嵌套，并保持架构的可预测性。

### 实用子代理模式

- 大规模重构：让主代理识别所有需要更改的文件，然后为每个逻辑组启动一个子代理。每个子代理负责自己的范围并返回摘要。主代理无需同时掌握每个文件的完整上下文。
- 代码审查流程：创建三个子代理：style-checker、security-scanner、test-coverage，并对一个 PR 并行运行。每个子代理都会以统一格式返回结果 → 主代理将其整合为一份审查报告。
- 研究任务：当你需要了解代码库中不熟悉的部分时，可以带着具体问题交给 Explore。它会返回相关文件和模式的精炼地图，让你的主要注意力集中在实际实现工作上。

## MCP Connectors：永不离开 Claude

MCP（模型上下文协议）是一种标准化方式，让 AI 模型通过统一接口调用外部工具和数据源，而无需为每个工具单独集成。你不需要进入 GitHub，也不需要进入 Slack、Gmail、Drive 等。你可以通过 Claude 界面，通过 MCP 服务器让 AI“对话”所有这些工具。

添加连接器的命令：

```bash
claude mcp add --transport http <名称> <网址>
```

或者如果你想用网页应用的简单方法：进入设置 → 连接器 → 找到你的服务器 → 配置 → 授权权限。

以下是过去六个月里 MCP 服务器为我做的一些事情：

- 实现问题跟踪器中的功能：“添加 JIRA 问题 ENG-4521 中描述的功能”
- 查询数据库：“查找上周注册的用户（来自我们的 PostgreSQL 数据库）”
- 集成设计：“根据新的 Figma 设计更新我们的邮件模板”
- 自动化工作流程：“为这些用户创建邀请他们参加反馈会话的 Gmail 草稿”
- 总结 Slack 讨论串：“团队在 #engineering 频道关于 API 重新设计做了什么决定？”

力量不在于某一个集成。

一个原本需要五次上下文切换的工作流程（查看问题追踪器、查看设计、回顾 Slack 讨论、实现代码、更新工单），现在可以在一个连续的会话中完成。你全天候都处于心流状态。

我建议连接以下 MCP 服务器：

- GitHub：代码仓库管理、问题、PR、代码搜索
- Slack：频道历史、线程摘要、消息搜索
- Google Drive：实施过程中可供参考的文档访问
- PostgreSQL/数据库：无需离开 Claude 即可直接查询
- Linear/Jira：问题跟踪集成

要查看你当前的 MCP 连接，请在 Claude Code 中运行 `/mcp`。

第三方 MCP 服务器未经 Anthropic 验证，请注意安全。对于敏感集成，请审查服务器的源代码，或使用服务提供商的官方连接器。

## 复合效应

这就是所有内容汇聚的地方：一个了解你代码库模式的技能 + 一个负责测试的子代理 + 与你的问题跟踪器的 MCP 连接 = 一个无与伦比的系统。

该技能会编码你团队的惯例。你无需担心上下文。子代理在处理复杂子任务的同时，能让你的主对话保持简洁。MCP 连接消除了让你分心的上下文切换。

我看到那些最能发挥 Claude Code 价值的工程师，并不是把它当作一次性的工具来用，而是把它当作提升工作能力的系统。他们会花时间配置技能、定义子代理、连接各种服务。这些投入之后，每完成一个任务都能带来应有的回报。

如果你不知道从哪里开始，就先选一个你经常反复解释的技能入手。或者只创建一个简单的智能体。然后测试一下，再逐步推进。没必要一下子什么都尝试，把自己搞得压力很大。

## TLDR 总结

- 上下文窗口并不相同。Claude Code 能稳定支持 20 万个 token。Cursor 实际上由于内部保护机制，通常会被截断到 7 万到 12 万 token。对于大型代码库来说，这很重要。
- 技能可以教会 Claude 你的专属工作流程。创建 `~/.claude/skills/skill-name/SKILL.md` 文件，包含 YAML 前言（名称、描述）和 Markdown 指令。当相关时，Claude 会自动应用这些技能。
- MCP 连接器消除了上下文切换。可连接 GitHub、Slack、数据库、问题跟踪器。将通常需要五个标签页的工作流串联成一个连续的会话。命令：`claude mcp add --transport http <name> <url>`
- 这些是复合的：技能编码模式，子代理处理子任务，MCP 连接服务。它们共同构建一个会随着使用而不断提升的系统。

